/*
[결혼식]
현수는 다음 달에 결혼을 합니다.
현수는 결혼식 피로연을 장소를 빌려 3일간 쉬지 않고 하려고 합니다.
피로연에 참석하는 친구들 N명의 참석하는 시간정보를 현수는 친구들에게 미리 요구했습니다.
각 친구들은 자신이 몇 시에 도착해서 몇 시에 떠날 것인지 현수에게 알려주었습니다.
현수는 이 정보를 바탕으로 피로연 장소에 동시에 존재하는 최대 인원수를 구하여 
그 인원을 수용할 수 있는 장소를 빌리려고 합니다. 
여러분이 현수를 도와주세요.
만약 한 친구가 오는 시간 13, 가는시간 15라면 
이 친구는 13시 정각에 피로연 장에 존재하는 것이고 15시 정각에는 존재하지 않는다고 가정합니다.
*/

/*
🥸 예상 풀이법
- (끝나는 시간 - 시작 시간)이 간 순으로 정렬한다.
- 시작 시간이 해당 친구의 시작 시간과 같거나 큰 || 끝 시간이 해당 친구의 끝 시간보다 작은 친구의 수를 Cnt ++

🚩 해답
1. 한 친구를 s와 e로 쪼갠다. > [14, s], [18, e], [12, s], [15, e], ...
2. 위의 배열을 정렬한다.
3. ⚠️ 같은 수일 경우 e가 먼저 오고 s가 나중에 와야 한다.
4. s를 만나면 ++, e를 만나면 --
*/

const solution = (arr) => {
  let answer = Number.MIN_SAFE_INTEGER;
  // 타임라인
  let tl = [];
  for (let x of arr) {
    tl.push(x[0], "s");
    tl.push(x[1], "e");
  }
  tr.sort((a, b) => {
    // 시간이 같다면 e가 먼저 오도록 문자열 오름차순 정렬 (아스키코드 기준)
    if (a[0] === b[0]) return a[1].charCodeAt() - b[1].charCodeAt();
    else return a[0] - b[0];
  });
  let cnt = 0;
  for (let x of tl) {
    if (x[1] === "s") cnt++;
    else cnt--;
    answer = Math.max(answer, cnt);
  }

  return answer;
};

console.log(
  solution([
    [14, 18],
    [12, 15],
    [15, 20],
    [20, 30],
    [5, 14],
  ])
);
