/*
[최대공약수와 최소공배수]
두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요.
배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다.
예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.

1) 최대공약수
    - 둘 중 작은 수 ~ 1 중에서 둘을 나눴을 때 모두 나머지가 0인 경우 stop
2) 최소공배수
    a. m % n === 0 >> 최소공배수는  m
    b. 최대공약수가 1이 아닌 경우 >> 최대공약수로 둘을 나눈 값끼리 곱해준 값이 최소곧배수
    c. 최대공약수가 1인 경우 >> n X m이 최소공배수

*/

function solution(n, m) {
  const a = Math.min(n, m);
  const b = Math.max(n, m);

  let 최대공약수 = 1;
  for (let i = 2; i <= a; i++) {
    if (a % i === 0 && b % i === 0) {
      최대공약수 = i;
    }
  }

  const 최소공배수 = 최대공약수 * (a / 최대공약수) * (b / 최대공약수);

  return [최대공약수, 최소공배수];
}

console.log(solution(3, 12));
console.log(solution(2, 5));
console.log(solution(18, 6));
console.log(solution(11, 121));

/* 
[유클리드 호제법]
1) 최대공약수
    - MOD 연산 반복하기 : 두 값을 나눈 나머지를 구하는 연산
    - 큰 수 % 작은 수 = 나머지1
      작은 수 % 나머지1 = 나머지2
      ...
      나머지n % 나머지m = 0
    - 나머지가 0이 됐을 때 마지막 계산에서 나누는 수로 사용된 나머지 m이 (큰 수)와 (작은 수)의 최대공약수!
2) 최소공배수
    - (최대공약수) * (큰 수 / 최대공약수) * (작은 수 / 최대공약수)
*/
